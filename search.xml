<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Shuffle strategic for limited resources</title>
      <link href="2021/12/27/Shuffle-strategic-for-limited-resources/"/>
      <url>2021/12/27/Shuffle-strategic-for-limited-resources/</url>
      
        <content type="html"><![CDATA[<p>On the early stage of Machine Learning, Data Mining progress, one of the problems we have to deal with processing large-size file, including corpus shuffle, usually its size would be larger than our limited resources like memory or capacity. Let’s say, the file is 30GB, whereas the provided memory is 8GB or 16GB, we surely cannot load entire them to memory in term of resource shuffling distribution notion. Therefore, the strategic tends to serve that case called Lazy Shuffling Algorithm allowing us to generally trade off time and capacity for memory allocation.</p><h1 id="Shuffle-Algorithm"><a href="#Shuffle-Algorithm" class="headerlink" title="Shuffle Algorithm"></a>Shuffle Algorithm</h1><p>In Computer Science, mixing dataset randomly required unpredictable randomness method, that pure randomness leads the data to be more natural sense. Due to the fact that computer only creates a <em>true random number</em> indeed an external event from real world, by other words, it measures some type of physical phenomenon that takes place outside of the computer like keyboard typing, mouse moving, temporature, treated as environment seeds to make sure generated numbers cannot be reproduced by some kind of reverse engineering.</p><p><img src="/images/pasted-10.png" alt="Random number"></p><p>Actually, the true data shuffling with high and perfect expectation could be somewhere fulfill by <em>pseudorandom generator</em>, these random numbers completely created by algorithm and seed value, instead of external event factors are also reluctantly acceptable, since sequence results are closer to truly random in several proven experiments. From there, Fisher Yates shuffle algorithm, leverages the perspective of pseudorandom generator approach, says </p><pre><code class="text">-- To shuffle an array a of n elements (indices 0..n-1):for i from n−1 downto 1 do     j ← random integer such that 0 ≤ j ≤ i     exchange a[j] and a[i]</code></pre><p>Wiki: <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle</a></p><p>The algorithm inspired by pseudorandom generator approach to randomly permutate in-memory swapping throughout entire dataset, thus, the in-place update does not incurred new dataset, of course no more spaces required before and after executing. But when if memory issue is a big deal, which would become puzzled to apply.</p><h1 id="Lazy-Shuffle-Algorithm"><a href="#Lazy-Shuffle-Algorithm" class="headerlink" title="Lazy Shuffle Algorithm"></a>Lazy Shuffle Algorithm</h1><p>Considering space is adjustable and time could be as fast as possible excepts memory is finite, we are not able to load whole large data based on FY Shuffle, then we have to improve it as Lazy Shuffle Algorithm, working around by shuffling index first, seeking and assigning new shuffled data later. Below algorithm serves the line by line format, if the file is a binary, we will have same approach but more complicated on binary serial structure.</p><ul><li>Load line by line and save the cursor offset, aka line map on each line into the offset_list. For example line 1 ends at 30, line 2 ends at 60 and so on, the offset_list should be <code>offset_list = [0, 30, 60, .... 40]</code></li><li>Create the index_list from range 0 to length of the offset_list, then the line 1 marked as index 0, line 2 marked as index 1,… The index_list must be <code>index_list = [0, 1, 2, 3, 4...., n]</code></li><li>Conduct shuffling index_list, in view of the fact that index_list contains only those indices, so it will not too much large resource basically. The sequence results would be also index_list object (because of in-place swapping) likely as <code>index_list = [4504, 134, 27676, 364756, 4...., 43]</code></li><li>Looping through shuffled index_list, we will leverage the offset_list to quickly access to the line, for example, <code>index_list[0] = 4504</code> and <code>offset_list[4504] = 490478</code>, seek file cursor <code>f</code> by <code>f.seek(490478)</code> and <code>new_line = f.readline()</code>, then appended writes <code>new_line</code> sequetially in a new file instead of in-place swapping. </li></ul><h1 id="Python-implementation"><a href="#Python-implementation" class="headerlink" title="Python implementation"></a>Python implementation</h1><p>I have prepared the 5.6GB file aggregated by binhvq, uncompressed ~27.5GB:<br><a href="https://github.com/binhvq/news-corpus#full-txt-v2">https://github.com/binhvq/news-corpus#full-txt-v2</a></p><p>To easier demo, I will use colab for the whole algorithm, firsly, download the file and wait for completion.</p><pre><code class="python">!gdown --id 1GFbe-qs6HmCYs0JwJgivOy2Bvb06M8OI!7z e corpus-full-20181217.7z</code></pre><p>It will take ~10 min to finish process, so let move to next section</p><p>To seek the file partially, the example here<br><a href="https://gist.github.com/JosephCatrambone/25476e9a37e932e50c527fc41e164e07">https://gist.github.com/JosephCatrambone/25476e9a37e932e50c527fc41e164e07</a></p><p>I modify a bit the class <code>LineSeekableFile</code>, on the first time initialization, the line will be loop entire the file, but only keep line positions to <code>line_map</code> aka <code>offset_list</code>, I set 10 lines read to easier testing</p><pre><code class="python">class LineSeekableFile:    def __init__(self, f):        self.fin = f        # create the line map starting by 0        self.line_map = [0]        self.line_count = 0                file_pos = 0        for line in f:            file_pos += len(line)            self.line_map.append(file_pos)            self.line_count += 1            # Break for testing purpose            if self.line_count == 10:                break    def __getitem__(self, index):        # NOTE: This assumes that you&#39;re not reading the file sequentially.          # For that, just use &#39;for line in file&#39;.        self.fin.seek(self.line_map[index])        return self.fin.readline()</code></pre><p>The <code>index_list</code> created by <code>line_count</code>, so when it reads 10 lines, it will get 10 lines and shuffle in that scope</p><pre><code class="python">import randomwith open(&#39;corpus-full-0.2.txt&#39;, &#39;r&#39;, encoding=&#39;utf8&#39;,errors=&quot;ignore&quot;) as f, open(&#39;new-corpus.txt&#39;, &#39;w&#39;, encoding=&#39;utf8&#39;,errors=&quot;ignore&quot;) as fw:    seeker = LineSeekableFile(f)    index_list = list(range(seeker.line_count))    # Fisher Shuffle    random.shuffle(index_list)    for i in range(seeker.line_count):        print(f&#39;Row &#123;i&#125;, swap with &#123;index_list[i]&#125;&#39;)        print(f&#39;Origin &#123;i&#125;, &#123;seeker[i]&#125;&#39;)        print(f&#39;Shuffled &#123;index_list[i]&#125;, &#123;seeker[index_list[i]]&#125;&#39;)        print(&#39;-----&#39;)        fw.write(seeker[index_list[i]])</code></pre><p>After finish testing, you can remove the print message and the breaking line to see performance. </p><p>Full code here: <a href="https://colab.research.google.com/drive/1rRO5u_WpXYkRdq3lugW-ed2v0UH525G5?usp=sharing">https://colab.research.google.com/drive/1rRO5u_WpXYkRdq3lugW-ed2v0UH525G5?usp=sharing</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Lazy Shuffle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kỷ nguyên Digital Transformation</title>
      <link href="2021/09/21/Ky-nguyen-Digital-Transformation/"/>
      <url>2021/09/21/Ky-nguyen-Digital-Transformation/</url>
      
        <content type="html"><![CDATA[<p>Những năm gần đây, một trong những thuật ngữ được nhắc đến rất nhiều trong Cách mạng Công nghiệp 4.0 thì không thể không kể đến Digital Transformation, hay còn gọi là Chuyển Đổi Số (CDS). Vậy CDS là gì mà các doanh nghiệp đang lưu tâm, nó có đóng góp cho sự thay đổi nào cho doanh nghiệp không? Có mang lại lợi ích lớn nào không?</p><h1 id="Lich-su"><a href="#Lich-su" class="headerlink" title="Lịch sử"></a>Lịch sử</h1><p>Để hiểu về CDS, trước hết mình cần phải hiểu và tránh nhầm lẫn với những thuật ngữ khác như Số Hóa (Digitization), Kỹ Thuật Số Hóa (Digitalization), và Ứng Dụng Số Hóa (Digitalized Application).</p><p>Từ thời xa xưa, khi con người biết sử dụng giấy để ghi chép lại thông tin, họ luôn muốn lưu giữ hoặc truyền bá thông điệp một cách hiệu quả. Chẳng hạn như thời phong kiến, nếu muốn truyền thông tin đến công chúng một cách rộng rãi và nhanh chóng, họ sẽ lựa chọn khắc gỗ bản gốc và cho in hàng loạt.</p><p>Thời cận đại, máy gõ chữ giúp người gõ văn bản nhanh chóng, nhân loại đã có bước tiến, nhưng chưa đủ</p><p><img src="/images/pasted-7.png" alt="Máy gõ chữ"></p><p>Con người tiếp tục phát minh ra bộ nhớ lưu trữ, văn bản được nhập liệu trực tiếp và được in hoặc in khi cần. Đến đây, thuật ngữ Số Hóa (Digitization) được dùng để miêu tả quá trình đưa dữ liệu vật lý sang dạng số và lưu trữ được.</p><p>Các công việc Số Hóa sẽ bao gồm:</p><ul><li>Soạn thảo văn bản, tài liệu, số liệu</li><li>Ghi âm </li><li>Scan giấy, hình vật lý sang định dạng hình ảnh của máy tính</li></ul><p>Những tài liệu này sẽ được gửi email, được phổ biến rộng rãi từ nơi này sang nơi khác nhanh hơn, được lưu trữ ở một nơi nào đó an toàn hơn. Các công việc, kinh doanh cũng sẽ được thao tác thực hiện trên máy tính nhiều hơn.</p><p>Về doanh nghiệp, sẽ thật thiếu sót nếu không kể đến các Ứng Dụng Số Hóa (Digitalized Application), đó có thể là mức độ thấp như Word, Excel, Powerpoint cho đến các mức độ cao như ERP, CRM, SAP để tối ưu hóa luồng công việc, giảm thiếu chi phí thực hiện từ hai phía nội bộ doanh nghiệp và lĩnh vực doanh nghiệp đang kinh doanh.</p><p>Khi có ứng dụng rồi, thì người quản lý dữ liệu đó phải học cách khai thác, một doanh nghiệp nhỏ có thể sử dụng Excel để làm thống kê, đưa ra phương hướng quyết định, nhưng khi mức độ nhiều hơn, số lượng dữ liệu quá lớn, thì bắt buộc phải có Kỹ Thuật Số Hóa để phù hợp với từng nhánh chuyên sâu hơn. Doanh nghiệp có thể đặt hàng công ty dữ liệu để đưa ra các Insights, ví dụ như các biểu đồ, thống kê, xu hướng, độ tin cậy của một mô hình,… Để từ đó lập kế hoạch, chiến dịch cho tương lai</p><p>Nhìn chung, sự áp dụng Kỹ Thuật Số đã đi sâu vào đời sống doanh nghiệp, từ mức độ thấp cho đến mức độ cao. Nhưng khi bước vào giai đoạn mới, gọi là Chuyển Đổi Số, nó lại liên quan đến văn hóa (Culture) nhiều hơn là kỹ thuật (Technology)</p><h1 id="Chuyen-doi-so"><a href="#Chuyen-doi-so" class="headerlink" title="Chuyển đổi số"></a>Chuyển đổi số</h1><p>Các doanh nghiệp lâu đời sẽ rất khó ứng dụng chuyển đổi số một cách nhanh chóng so với những doanh nghiệp khởi nghiệp, do họ còn tồn tại các quy trình, các văn hóa, tất nhiên điều đó không sai nếu xét về mặt ổn định.</p><p><img src="/images/pasted-8.png" alt="Netflix"></p><p>Ví dụ về công ty Netflix, năm 1997, công ty đang định hình ở mảng cho thuê DVD qua thư bưu điện, 10 năm sau Netflix cho phép phát hành video online, cho đến hiện nay đã rất thành công trong việc bán subscription để người dùng được thưởng thức không chỉ series truyền hình mà còn cả phim rạp. Từ đó, hình thành văn hóa xem phim online thay cho băng đĩa hay truyền hình cáp truyền thống. Nói cách khác, Netflix đã chủ động thay đổi và từng bước đưa giải pháp để người xem tiếp cận được tiện ích giải trí.</p><p><img src="/images/pasted-9.png" alt="Dropbox"></p><p>Công ty Dropbox khởi nghiệp với mục tiêu thay đổi cách gửi file qua email hay USB vì sẽ có rủi ro virus và mất mát. Qua đó định hình được văn hóa sử dụng Cloud Computing để lưu trữ (SaaS)</p><p>Trong thời gian dịch vừa qua, rất rõ ràng có nhiều tổ chức đã phải quyết định thực hiện Ứng Dụng Số Hóa một cách đột ngột:</p><ul><li>Nhà trường sử dụng Zoom để dạy online</li><li>Hàng hóa, rau củ, chợ được bày bán ở Facebook, Zalo</li><li>Công việc được làm ở nhà, quy trình giấy tờ được giảm bớt</li></ul><p>Có thể thấy, xã hội sẽ phải đối mặt với việc CDS ở rất nhiều lĩnh vực, không nhất thiết tổ chức doanh nghiệp buộc phải có AI, IoT, Big Data,… những suy nghĩ đấy không hẳn đúng hoàn toàn. Hai công ty ví dụ phía trên đều không có áp dụng những kỹ thuật tiên tiến ngay thời buổi ban đầu, nhưng nhờ CDS, họ có thể áp dụng rất nhiều kỹ thuật đó để ngày càng phát triển hơn, nói cách khác, CDS là tiền đề để áp dụng khoa học công nghệ và kỹ thuật.</p><h1 id="Dieu-kien-de-chuyen-doi-so"><a href="#Dieu-kien-de-chuyen-doi-so" class="headerlink" title="Điều kiện để chuyển đổi số"></a>Điều kiện để chuyển đổi số</h1><h2 id="Fault-tolerance-from-Leader"><a href="#Fault-tolerance-from-Leader" class="headerlink" title="Fault tolerance from Leader"></a>Fault tolerance from Leader</h2><p>Luôn khoan dung với lỗi lầm và rủi ro có thể xảy ra đối với CDS, các lãnh đạo doanh nghiệp phải nhận thức được tầm quan trọng của CDS, để từ đó đưa ra lộ trình, ngân sách và hướng giải quyết khi mắc lỗi lầm.</p><h2 id="Technology-skills-amp-security-issue"><a href="#Technology-skills-amp-security-issue" class="headerlink" title="Technology skills &amp; security issue"></a>Technology skills &amp; security issue</h2><p>Các phòng ban phải có kỹ năng công nghệ thông tin nhất định và cũng phải có nhận thức về bảo mật thông tin. Ngoài ra phòng ban cũng phải có ý chí để tiếp thu được công nghệ, qua đó đóng góp được hướng xử lý tốt hơn.</p><p>Ví dụ: Ban lãnh đạo muốn sử dụng máy quét vân tay, KPI hoàn thành, để đo đạc được chất lượng của nhân viên. Các quy trình xin nghỉ phép, hạch toán, lương bổng phải được tự động hóa. Những bài toán này được đặt cho Team HR và Dev để cùng nhau thực hiện, tuy nhiên, HR chỉ muốn làm trên Excel vì nó này nọ kia, thì Dev cho dù có cố gắng cũng không thể thực hiện CDS triệt để, vì Dev và HR không hiểu nhau.</p><h2 id="Custommer-understanding"><a href="#Custommer-understanding" class="headerlink" title="Custommer understanding"></a>Custommer understanding</h2><p>Lấy khách hàng là trọng tâm để hoạch định chiến lược CDS. Từ những thành công trước đó về CDS của Netflix và Dropbox, một khi khách hàng hiểu sản phẩm của mình và cảm thấy thật sự giải quyết được những bất tiện họ đang gặp phải, họ sẵn sằng chi hầu bao cho dịch vụ đó.</p><h2 id="Agile-Transformation"><a href="#Agile-Transformation" class="headerlink" title="Agile Transformation"></a>Agile Transformation</h2><p>Từng bước CDS từ các phòng ban cho đến toàn hệ thống. Ví dụ, Team Marketing sẽ phải biết sử dụng SQL &amp; BI để đọc Insights data và đưa ra các chiến lược Marketing. Thay vì những công việc này vốn phải là đơn đặt hàng cho Team Data</p><p>Ngoài ra, Agile Transformation còn có ý nghĩa là việc CDS phải luôn liên tục và không ngừng nghỉ để đáp ứng được với xu hướng của thời đại.</p><h1 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h1><ul><li>Chuyển đổi số liên quan đến văn hóa, nhiều hơn là công nghệ</li><li>Chuyển đổi số không cần thiết phải có áp dụng AI, IoT, Big Data mà là tiền đề để áp dụng nó</li><li>Doanh nghiệp thay đổi cần tập trung dịch vụ hướng người dùng một cách tốt nhất</li><li>Chuyển đổi số là liên tục, không ngừng nghỉ</li><li>Các phòng ban và lãnh đạo phải có ý chí thực hiện Chuyển đổi số để nâng cao hiệu quả công việc</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Digital Transformation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tìm trung vị của 2 dãy đã được sắp xếp</title>
      <link href="2021/09/03/Tim-trung-vi-cua-2-day-da-duoc-sap-xep/"/>
      <url>2021/09/03/Tim-trung-vi-cua-2-day-da-duoc-sap-xep/</url>
      
        <content type="html"><![CDATA[<p>Cho hai dãy <code>nums1</code>, <code>nums2</code> đã được sắp xếp theo thứ tự có size là <code>m</code> và <code>n</code>, hãy tìm trung vị (median) của hai dãy đó.</p><p>Đây là bài toán được xem là mức độ khó trên <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">leetcode.com</a>, thách thức của bài này là thuật toán phải được chạy với time <code>O(log(m+n))</code></p><p>Nguyên văn bài toán và các ví dụ</p><blockquote><p>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.</p></blockquote><blockquote><p>The overall run time complexity should be O(log (m+n)).</p></blockquote><blockquote><p>Example 1:<br>Input: nums1 = [1,3], nums2 = [2]<br>Output: 2.00000<br>Explanation: merged array = [1,2,3] and median is 2.</p></blockquote><blockquote><p>Example 2:<br>Input: nums1 = [1,2], nums2 = [3,4]<br>Output: 2.50000<br>Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.</p></blockquote><blockquote><p>Example 3:<br>Input: nums1 = [0,0], nums2 = [0,0]<br>Output: 0.00000</p></blockquote><blockquote><p>Example 4:<br>Input: nums1 = [], nums2 = [1]<br>Output: 1.00000</p></blockquote><blockquote><p>Example 5:<br>Input: nums1 = [2], nums2 = []<br>Output: 2.00000</p></blockquote><h1 id="Trung-vi-la-gi"><a href="#Trung-vi-la-gi" class="headerlink" title="Trung vị là gì?"></a>Trung vị là gì?</h1><p>Khác với trung bình, trung vị là vị trí phần tử ở chính giữa của một dãy đã sắp xếp, vị trí đó cho biết giá trị điển hình của dãy đó. Nếu dãy có số lượng phần tử là lẻ, thì sẽ lấy phần tử ở giữa, ngược lại là chẵn, thì sẽ lấy trung bình của 2 phần tử ở giữa</p><h1 id="Huong-tiep-can-1"><a href="#Huong-tiep-can-1" class="headerlink" title="Hướng tiếp cận 1"></a>Hướng tiếp cận 1</h1><p>Hướng tiếp cận ban đầu, dễ nhất chính là sử dụng một dãy merge chứa toàn bộ phần tử củ hai dãy, sau đó cài đặt thuật toán sắp xếp lại rồi tìm trung vị như công thức.</p><pre><code class="python">    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        nums = nums1 + nums2        #sort in-place memory        nums.sort()         length = len(nums)                return (nums[int(length/2)-1] + nums[int(length/2)])/2 if length % 2 == 0 else nums[int(length/2)]</code></pre><p>Lợi ích của code này là bạn không cần quan tâm đến việc <code>sort()</code> của code được chạy như thế nào, thực tế, python sử dụng thuật toán <code>Timsort</code>, giải quyết được tổng quát đa số trường hợp để có time and space complexity thấp nhất, bạn có thể tham khảo thêm tại: </p><p><a href="https://en.wikipedia.org/wiki/Timsort">https://en.wikipedia.org/wiki/Timsort</a></p><blockquote><p>Timsort is a hybrid sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. It was invented by Tim Peters in 2002 for use in the Python programming language. The algorithm finds subsets of the data that are already ordered, and uses the subsets to sort the data more efficiently. This is done by merging an identified subset, called a run, with existing runs until certain criteria are fulfilled. Timsort has been Python’s standard sorting algorithm since version 2.3. It is now also used to sort arrays in Java SE 7, and on the Android platform.</p></blockquote><p>Tuy vậy, việc bạn sử dụng <code>sort()</code> lại <strong>không thực sự tối ưu</strong>, cũng bởi vì code quá ngắn, tinh túy của bài toán bạn chưa thực sự chạm vào, thì không một interviewer nào chấp nhận code này làm câu trả lời cuối cùng</p><p><img src="/images/pasted-6.png" alt="Ở đây chúng tôi không làm thế ;)"></p><h1 id="Huong-tiep-can-2"><a href="#Huong-tiep-can-2" class="headerlink" title="Hướng tiếp cận 2"></a>Hướng tiếp cận 2</h1><p>Khi bạn <strong>được reject</strong> câu trả lời trên, thì bạn sẽ bảo “Ồ, vậy tôi thử tìm một giải thuật sắp xếp nào đó để được <code>O(log(m+n))</code> xem sao”. Nếu bạn được nhớ lại, hoặc may mắn được interviewer nhắc bài “Cho tới hiện nay, không một chương trình tuyến tính nào có thể cài đặt thuật toán sort tốt hơn <code>O((n+m)log(n+m))</code>“. Nói như vậy không có nghĩa bạn lại đi cài đặt parallel nhé :)</p><p>Đúc kết lại, nếu bạn cố tìm thuật toán merge 2 dãy đã sắp xếp lại, thì nó không phải là câu trả lời interviewer muốn nghe</p><p>Nếu bạn có hứng thú với thuật toán merge này, bạn có thể tham khảo tại: <a href="https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space/">https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space/</a></p><h1 id="Huong-tiep-can-3"><a href="#Huong-tiep-can-3" class="headerlink" title="Hướng tiếp cận 3"></a>Hướng tiếp cận 3</h1><p>Xem lại bài toán, xét 2 khía cạnh của đề bài:</p><ol><li>Hai dãy đã được sắp xếp</li><li>Chỉ quan tâm số ở giữa để tìm trung vị</li></ol><p>=&gt; Cần thiết để phải sort lại toàn bộ khi mình chỉ cần 1, 2 phần tử ở giữa?</p><h2 id="Y-tuong-chinh"><a href="#Y-tuong-chinh" class="headerlink" title="Ý tưởng chính"></a>Ý tưởng chính</h2><p>Xét 2 dãy <code>A = [3, 6, 8, 9, 10]</code> và <code>B = [1, 4, 12]</code>. </p><p>Dãy merge đã sắp xếp sẽ là <code>C = [1, 3, 4, 6, 8, 9, 10, 12]</code> =&gt; Dãy <code>Median(C) = (6 + 8)/2 = 7</code></p><p>Nếu tôi cắt đôi dãy A và dãy A, 2 dãy bên trái gọi là nhóm X, 2 dãy bên phải gọi là nhóm Y, sao cho <strong>mỗi nhóm có số lượng bằng nhau hoặc chênh lệch một phần tử</strong> như sau</p><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3, 6, 8]</td><td>[9, 10]</td></tr><tr><td>[1]</td><td>[4, 12]</td></tr></tbody></table><p>Nếu nhóm X hoàn toàn thuộc về bên trái, nhóm Y hoàn toàn thuộc về bên phải, hay nói cách khác, <strong>Max(X) &lt;= Min(Y)</strong>, thì bạn đã ở vị trí chính giữa của 2 dãy, hoàn toàn có thể tìm được giá trị trung vị <strong>mà không cần phải sắp xếp 2 dãy đó</strong>. Việc của mình chỉ là dịch (shift) trái hoặc dịch phải các phần tử để đáp ứng tiêu chí đó. Nếu nhóm X cho nhóm Y một phần tử ở dãy A, thì nhóm Y cũng phải cho X một phần tử ở dãy B tương ứng. Nếu bạn nhìn kỹ thì nó như theo một chiều của kim đồng hồ.</p><p>Tôi thử shift chiều kim đồng hồ, kết quả:</p><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3, 6]</td><td>[8, 9, 10]</td></tr><tr><td>[1, 4]</td><td>[12]</td></tr></tbody></table><p>Nhận xét Max(X) = 6 &lt;= Min(Y) = 8. Do tổng số phần tử là chẵn, nên (6+8)/2 = 7 =&gt; giá trị cần tìm</p><p>Có 2 ràng buộc để solution này khả thi:</p><ul><li>Nếu dãy A hoặc B không được sắp xếp độc lập, bạn không thể shift</li><li>Bài toán chỉ để tìm trung vị</li></ul><p>Đây là core của bài toán, kỹ thuật này còn gọi là <code>Binary Search</code> - tìm kiếm nhị phân, các mục tiếp theo là đi sâu vào nhiều khía cạnh phải xem xét.</p><h2 id="Khong-con-kha-nang-shift"><a href="#Khong-con-kha-nang-shift" class="headerlink" title="Không còn khả năng shift"></a>Không còn khả năng shift</h2><p>Nếu tôi thay 12 bằng 5, bài toán cần thiết phải shift thêm 1 lần, như sau:</p><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3, 6]</td><td>[8, 9, 10]</td></tr><tr><td>[1, 4]</td><td>[5]</td></tr></tbody></table><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3]</td><td>[6, 8, 9, 10]</td></tr><tr><td>[1, 4, 5]</td><td>?</td></tr></tbody></table><p>=&gt; [1, 3, 4, 5, 6, 8, 9, 10] =&gt; Chọn (5+6)/2 = 5.5<br>=&gt; Uhmm, không quan trọng lắm, <code>?</code> thay bằng <code>Infinity</code> thì sẽ không bị gì, tương tự cho các trường hợp còn lại, thì bên Y bị rút hết thì sẽ là dương vô cực, X thì là âm vô cực.</p><h2 id="Truong-hop-lech-nhau-1-don-vi"><a href="#Truong-hop-lech-nhau-1-don-vi" class="headerlink" title="Trường hợp lệch nhau 1 đơn vị"></a>Trường hợp lệch nhau 1 đơn vị</h2><p>Giả sử tôi thêm 11 vào nhóm Y của dãy A</p><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3]</td><td>[6, 8, 9, 10, 11]</td></tr><tr><td>[1, 4, 5]</td><td>?</td></tr></tbody></table><p>=&gt; [1, 3, 4, 5, 6, 8, 9, 10, 11] =&gt; Chọn 6</p><p>=&gt; Nếu lệch ở đâu thì lấy phần tử gần trung tâm nhất của bên đó</p><h2 id="Co-ton-tai-lech-nhau-nhieu-hon-1-don-vi-ma-khong-the-shift"><a href="#Co-ton-tai-lech-nhau-nhieu-hon-1-don-vi-ma-khong-the-shift" class="headerlink" title="Có tồn tại lệch nhau nhiều hơn 1 đơn vị mà không thể shift?"></a>Có tồn tại lệch nhau nhiều hơn 1 đơn vị mà không thể shift?</h2><p>Không. Giả sử:</p><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3]</td><td>[6, 8, 9, 10, 13, 15]</td></tr><tr><td>[1, 4, 5]</td><td>?</td></tr></tbody></table><p>=&gt; Vi phạm việc chia đôi, chính xác ban đầu phải là:</p><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3, 6]</td><td>[8, 9, 10, 13, 15]</td></tr><tr><td>[1, 4, 5]</td><td>?</td></tr></tbody></table><h2 id="Lam-sao-de-biet-shift-chieu-nao"><a href="#Lam-sao-de-biet-shift-chieu-nao" class="headerlink" title="Làm sao để biết shift chiều nào?"></a>Làm sao để biết shift chiều nào?</h2><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3, 6 = O]</td><td>[8 = P, 9, 10]</td></tr><tr><td>[1, 4 = N]</td><td>[5 = M]</td></tr></tbody></table><p>Rất dễ nhận biết, xét 4 số trung tâm 6, 4, 8, 5, tướng ứng O, N, P, M</p><ul><li>Theo chiều kim nếu <code>O &gt; M</code>: 6 &gt; 5. Mà <code>N &lt;= M, O &lt;= P</code> =&gt; <code>P &gt;= O &gt; M &gt;= N</code> =&gt; <code>P &gt; N</code></li><li>Ngược chiều kim nếu <code>N &gt; P</code>. Mà <code>N &lt;= M, O &lt;= P</code> =&gt; <code>M &gt;= N &gt; P &gt;= O</code> =&gt; <code>M &gt; O</code></li></ul><p>Như vậy, chỉ tồn tại một trong 2 điều kiện đó có thể xảy ra. Đối với dấu <code>=</code>, thuật toán có thể kết thúc ngay, vd:</p><table><thead><tr><th>Nhóm X</th><th>Nhóm Y</th></tr></thead><tbody><tr><td>[3, 5 = O]</td><td>[5 = P, 9, 10]</td></tr><tr><td>[1, 5 = N]</td><td>[5 = M]</td></tr></tbody></table><p>=&gt; Max(X) = 5 &lt;= Minx(Y) = 5 =&gt; (5+5)/2 = 5</p><p>=&gt; <code>[1, 3, 5, 5, 5, 5, 9, 10]</code> =&gt; Chọn 5</p><h2 id="Dich-bao-nhieu-don-vi"><a href="#Dich-bao-nhieu-don-vi" class="headerlink" title="Dịch bao nhiêu đơn vị?"></a>Dịch bao nhiêu đơn vị?</h2><p>Để có được độ phức tạp <code>O(log(m+n))</code>, cần thiết phải search chia đôi liên tục thay vì dịch từng đơn vị 1. Nghĩa là, với độ dài <code>k = m + n</code>, mỗi vòng lặp sẽ thực hiện trên khoảng <code>k = k/2</code>, chọn nửa <code>k</code> bên nào sẽ do chiều shift quyết định. </p><h2 id="Cai-dat-tren-Python"><a href="#Cai-dat-tren-Python" class="headerlink" title="Cài đặt trên Python"></a>Cài đặt trên Python</h2><p>Thuật toán:</p><ul><li>Chọn A là dãy bé, B là dãy lớn</li><li>Khai báo các var</li><li><code>len_a</code>, <code>len_b</code> là size của dãy A, B</li><li><code>most_min</code>, <code>most_max</code> để sử dụng khi không thể shift</li><li><code>size_x</code> là size của nhóm X, mọi thao tác đều trên nhóm X</li><li><code>a_search_start</code> <code>a_search_end</code> định nghĩa khoảng trên dãy A mà BinarySearch sẽ nhảy vào. Mặc định khởi tạo sẽ bằng với khoảng của dãy A</li><li>Trong vòng lặp,</li><li><code>x_len_a</code>, <code>x_len_b</code> là độ dài dãy A, B trên nhóm X. Lần lặp đầu tiên <code>x_len_a</code> sẽ lấy khoảng nửa của dãy A, từ đó tìm ra <code>x_len_b</code>. Từ lần 2 trở đi, tùy vào chiều shift mà <code>a_search_start/end</code> quyết định <code>x_len_a</code> sẽ tăng hay giảm, dẫn đến <code>x_len_b</code> giảm hay tăng, tương ứng.</li><li><code>x_a</code>, <code>y_a</code>, <code>x_b</code>, <code>y_b</code> là 4 vị trí trung tâm đang xét</li><li>Nếu <code>Min(X) &lt;= Min(Y)</code>, tương ứng với <code>x_a &lt;= y_b and x_b &lt;= y_a</code>, xét chẵn lẻ của tổng dãy và ra kết quả</li><li>Ngược lại có 2 trường hợp xảy ra:</li><li>Nếu dịch theo chiều kim, <code>x_a &gt; y_b</code>, thì sẽ lùi  <code>a_search_end</code> một khoảng sao cho mốc mới sẽ bằng với <code>x_len_a</code> trừ một đơn vị</li><li>Ngược chiều kim, thì sẽ tăng <code>a_search_start</code> một khoảng sao cho mốc mới sẽ bằng với <code>x_len_a</code> thêm một đơn vị</li></ul><pre><code class="python">    def findMedianSortedArrays(self, A: List[int], B: List[int]) -&gt; float:        if len(A) &gt; len(B):            A, B = B, A                len_a, len_b = len(A), len(B)        most_min, most_max = float(&quot;-inf&quot;), float(&quot;inf&quot;)        size_x = (len_a + len_b + 1) // 2        a_search_start = 0        a_search_end = len_a        is_even = ((len_a + len_b) % 2) == 0        while True:                 x_len_a = (a_search_start + a_search_end) // 2            x_len_b = size_x - x_len_a                        x_a = most_min if x_len_a == 0 else A[x_len_a - 1]            y_a = most_max if x_len_a == len_a else A[x_len_a]            x_b = most_min if x_len_b == 0 else B[x_len_b - 1]            y_b = most_max if x_len_b == len_b else B[x_len_b]                        if x_a &lt;= y_b and x_b &lt;= y_a:                if is_even:                    return (max(x_a, x_b) + min(y_a, y_b))/ 2                                return max(x_a, x_b)                            if x_a &gt; y_b:                a_search_end = x_len_a - 1                continue                            if x_b &gt; y_a:                a_search_start = x_len_a + 1                continue</code></pre><h1 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h1><p>Đây là một trong các bài ứng dụng của Binary Search, tôi tham khảo và viết chú thích cũng tốn gần nửa ngày thời gian, mọi trích dẫn vui lòng dẫn nguồn. Cám ơn bạn đọc đã đọc hết bài viết.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithms </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quá trình tìm CTTQ của bài toán đổ xúc xắc</title>
      <link href="2021/04/03/Qua-trinh-tim-CTTQ-cua-bai-toan-do-xuc-xac/"/>
      <url>2021/04/03/Qua-trinh-tim-CTTQ-cua-bai-toan-do-xuc-xac/</url>
      
        <content type="html"><![CDATA[<p>Một trong những bài toán khá kinh điển khi học về Tổ hợp - Chỉnh hợp như sau</p><blockquote><p>Cho 2 viên xúc xắc (xí ngầu) cân đối đồng chất, hãy tìm số trường hợp có thể xảy ra trong một lần gieo, không phân biệt thứ tự</p></blockquote><p>Vì là cân đối, đồng chất, một lần gieo, không biệt thứ tự =&gt; Do đó cặp (x, y) đối xứng như (1, 6) (6, 1) là như nhau</p><p>Cách tìm đơn giản là vét cạn trâu bò nhất, cụ thể</p><blockquote><p>(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6)<br>(2, 2) (2, 3) (2, 4) (2, 5) (2, 6)<br>(3, 3) (3, 4) (3, 5) (3, 6)<br>(4, 4) (4, 5) (4, 6)<br>(5, 5) (5, 6)<br>(6, 6)</p></blockquote><p>Vậy có tổng cộng 21 trường hợp có thể xảy ra</p><p>Lúc đấy tôi đã đặt câu hỏi để mở rộng bài toán cho trường hợp n:</p><blockquote><p>Cho <em>n</em> viên xúc xắc (xí ngầu) cân đối đồng chất, hãy tìm số trường hợp có thể xảy ra trong một lần gieo, không phân biệt thứ tự</p></blockquote><p>Hoặc tổng quát hơn, nếu như xúc xắc có m mặt:</p><blockquote><p>Cho <em>n</em> viên xúc xắc (xí ngầu) có <em>m</em> mặt cân đối đồng chất, hãy tìm số trường hợp có thể xảy ra trong một lần gieo, không phân biệt thứ tự</p></blockquote><p>Công thức tổng quát (CTTQ) cho 2 trường hợp này sẽ như nào?</p><h1 id="Hanh-trinh-cu"><a href="#Hanh-trinh-cu" class="headerlink" title="Hành trình cũ"></a>Hành trình cũ</h1><p>Bằng trâu bò, tôi tạm thời vét cạn ra các trường hợp như sau:</p><blockquote><p>$n = 1$ viên =&gt; $S_1 = 6$ trường hợp<br>$n = 2$ viên =&gt; $S_2 = 21$ trường hợp<br>$n = 3$ viên =&gt; $S_3 = 56$ trường hợp<br>$n = 4$ viên =&gt; $S_4 = 126$ trường hợp<br>$n = 5$ viên =&gt; $S_5 = 252$ trường hợp</p></blockquote><p>Xét danh sách phần tử cấu thành nên $S_2$</p><blockquote><p>(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) = 6<br>(2, 2) (2, 3) (2, 4) (2, 5) (2, 6) = 5<br>(3, 3) (3, 4) (3, 5) (3, 6) = 4<br>(4, 4) (4, 5) (4, 6) = 3<br>(5, 5) (5, 6) = 2<br>(6, 6) = 1</p><p>Tổng từ dưới lên $S_2 = 1 + 2 + 3 + 4 + 5 + 6 + 21$</p></blockquote><p>Xét danh sách phần tử cấu thành nên $S_3$</p><blockquote><blockquote><p>(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4), (1, 1, 5), (1, 1, 6),  = 6</p><p>– (1, 2, 2), (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 2, 6), = 5 </p><p>– (1, 3, 3), (1, 3, 4), (1, 3, 5), (1, 3, 6),  = 4</p><p>– (1, 4, 4), (1, 4, 5), (1, 4, 6), = 3</p><p>– (1, 5, 5), (1, 5, 6), = 2<br>– (1, 6, 6), = 1</p><p>$1 + 2 + 3 + 4 + 5 + 6 = 21$</p></blockquote><blockquote><p>(2, 2, 2), (2, 2, 3), (2, 2, 4), (2, 2, 5), (2, 2, 6),  = 5</p><p>– (2, 3, 3), (2, 3, 4), (2, 3, 5), (2, 3, 6), = 4</p><p>– (2, 4, 4), (2, 4, 5), (2, 4, 6), = 3<br>– (2, 5, 5), (2, 5, 6), = 2<br>– (2, 6, 6), = 1</p><p>$1 + 2 + 3 + 4 + 5 = 15$</p></blockquote><blockquote><p>(3, 3, 3), (3, 3, 4), (3, 3, 5), (3, 3, 6), = 4</p><p>– (3, 4, 4), (3, 4, 5), (3, 4, 6), = 3<br>– (3, 5, 5), (3, 5, 6), = 2</p><p>– (3, 6, 6),  = 1</p><p>$1 + 2 + 3 + 4 = 10$</p></blockquote><blockquote><p>(4, 4, 4), (4, 4, 5), (4, 4, 6), = 3</p><p>– (4, 5, 5), (4, 5, 6), = 2</p><p>– (4, 6, 6), = 1</p><p>$1 + 2 + 3 = 6$</p></blockquote><blockquote><p>(5, 5, 5), (5, 5, 6),  = 2 </p><p>– (5, 6, 6), = 1</p><p>$1 + 2 = 3$</p></blockquote><blockquote><p>(6, 6, 6) = 1</p></blockquote><p>Tổng từ dưới lên $S_3 = 1 + 3 + 6 + 15 + 21 = 56$</p></blockquote><p>Sau khi xét danh sách này xong, tôi nhận thấy nỗ lực dùng các công thức tổ hợp là không có ý tưởng. Tuy nhiên cũng từ danh sách này, tôi thử liệt kê các phần tử thành dạng bảng như sau:</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th><th></th><th></th><th></th><th>U</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td>1</td><td>1</td><td>1</td><td>6</td></tr><tr><td align="left">1</td><td align="left">2</td><td align="left">3</td><td>4</td><td>5</td><td>6</td><td>21</td></tr><tr><td align="left">1</td><td align="left">3</td><td align="left">6</td><td>10</td><td>15</td><td>21</td><td>56</td></tr></tbody></table><p>Rất dễ nhận thấy quy luật, <code>phần tử hiện tại</code> trừ đi <code>phần tử liên kề bên trái</code> sẽ bằng với giá trị của <code>phần tử cùng dãy ở trên</code> (1)</p><blockquote><p>Dòng 3: </p><p>$3 - 1 = 2$</p><p>$6 - 3 = 3$</p><p>$10 - 6 = 4$</p><p>$15 - 10 = 5$</p><p>$21 - 15 = 6$</p></blockquote><p>Tôi thử phát triển bảng này lên, bằng cách cứ mỗi ô từ trái sang phải, lấy <em>phần tử trái cộng phần tử ở trên</em>.</p><table><thead><tr><th align="left">$m_1$</th><th align="left">$m_2$</th><th align="left">$m_3$</th><th>$m_4$</th><th>$m_5$</th><th>$m_6$</th><th>Total $S_n$</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td>1</td><td>1</td><td>1</td><td>$S_1 = 6$</td></tr><tr><td align="left">1</td><td align="left">2</td><td align="left">3</td><td>4</td><td>5</td><td>6</td><td>$S_2 = 21$</td></tr><tr><td align="left">1</td><td align="left">3</td><td align="left">6</td><td>10</td><td>15</td><td>21</td><td>$S_3 = 56$</td></tr><tr><td align="left">1</td><td align="left">4</td><td align="left">10</td><td>20</td><td>35</td><td>56</td><td>$S_4 = 126$</td></tr><tr><td align="left">1</td><td align="left">5</td><td align="left">15</td><td>35</td><td>70</td><td>126</td><td>$S_5 = 252$</td></tr><tr><td align="left">1</td><td align="left">6</td><td align="left">21</td><td>56</td><td>126</td><td>252</td><td>$S_6 = 462$</td></tr></tbody></table><p>Từ bảng này tôi có thể đưa n và kéo dài cột (m mặt) để ra kết quả. Phương pháp này không hẳn là nhanh, nhưng cơ bản có thể hình dung được tổng quan.</p><h1 id="Khao-sat"><a href="#Khao-sat" class="headerlink" title="Khảo sát"></a>Khảo sát</h1><p>Tôi thử code trên jupyter để khảo sát tình huống này, mở rộng ra <code>n xúc xắc</code>, code này cũng có thể phục vụ <code>m mặt</code> bằng cách thay đổi <code>m_dice</code></p><pre><code class="python">import numpy as npimport pandas as pdn = 100m_dice = 6def get_table(n, m_dice):    table = np.ones((n, m_dice))    for k in range(1, n):           for i in range(1, m_dice):            table[k, i] = table[k, i-1] + table[k-1, i]    return tabledf = pd.DataFrame(columns = [&#39;n&#39;, &#39;m_1&#39;,&#39;m_2&#39;, &#39;m_3&#39;, &#39;m_4&#39;, &#39;m_5&#39;, &#39;m_6&#39;,&#39;S_n&#39;])table = get_table(n, 6)for i in range(1, n):    new_row = &#123;        &#39;n&#39;: i ,        &#39;m_1&#39;: table[i-1][0],        &#39;m_2&#39;: table[i-1][1],        &#39;m_3&#39;: table[i-1][2],        &#39;m_4&#39;: table[i-1][3],        &#39;m_5&#39;: table[i-1][4],        &#39;m_6&#39;: table[i-1][5],        &#39;S_n&#39;: table.sum(axis=1)[i-1]    &#125;    df = df.append(new_row, ignore_index=True)</code></pre><p><img src="/images/pasted-1.png"></p><p>Đường $m_6$ và $S_n$ đang đi gần giống nhau, ít nhiều cũng có mối quan hệ mật thiết, ngoài ra đường cong này cũng cho biết phương trình của $m_6$ và $S_n$ chắc chắn cũng phải bậc 2 trở lên.</p><table><thead><tr><th>$m_6$</th><th>Total $S_n$</th></tr></thead><tbody><tr><td>1</td><td>$S_1 = 6$</td></tr><tr><td>6</td><td>$S_2 = 21$</td></tr><tr><td>21</td><td>$S_3 = 56$</td></tr><tr><td>56</td><td>$S_4 = 126$</td></tr><tr><td>126</td><td>$S_5 = 252$</td></tr><tr><td>252</td><td>$S_6 = 462$</td></tr></tbody></table><p>Quay lại bảng, có thể thấy, $S_n$ bằng với $m_6$ của $n+1$ (2)</p><p>Từ (1), (2) hệ thống lại như sau:</p><blockquote><p>$n$ là số viên xúc xắc</p><p>$m$ là số mặt của xúc xắc</p><p>$u_{m,n}$ là phần tử thứ $m$ của dãy $n$</p><p>$S_{m,n} = u_{m,n} + u_{m-1,n} + u_{m-2,n} + .. + u_{1,n}$ </p><p>$u_{m,n} = u_{m-1,n} + u_{m,n-1}$</p><p>$u_{m,1} = 1$, $u_{1,n} = 1$ </p></blockquote><ol><li>Tìm CTTQ của $S_{m,n}$ hoặc $u_{m,n}$</li><li>Chứng minh $S_{m,n} = u_{m,n+1}$</li></ol><h2 id="Su-dung-day-cong-thuc-truy-hoi"><a href="#Su-dung-day-cong-thuc-truy-hoi" class="headerlink" title="Sử dụng dãy công thức truy hồi"></a>Sử dụng dãy công thức truy hồi</h2><p>Tôi không đi vào tiếp cận này vì nó quá phức tạp, thay vào đó, tôi sử dụng liên hệ với tam giác Pascal phần tiếp theo</p><h2 id="Su-dung-lien-he-voi-Tam-giac-Pascal"><a href="#Su-dung-lien-he-voi-Tam-giac-Pascal" class="headerlink" title="Sử dụng liên hệ với Tam giác Pascal"></a>Sử dụng liên hệ với Tam giác Pascal</h2><p>Ta có</p><blockquote><p>$u_{m,1} = 1$, $u_{1,n} = 1$</p><p>$u_{2,2} = u_{2-1,2} + u_{2,2-1} = u_{1,2} + u_{2,1} = 1 + 1 = 2$</p><p>$u_{2,3} = u_{2-1,3} + u_{2,3-1} = u_{1,3} + u_{2,2} = 1 + 2 = 3$ </p><p>$u_{3,2} = u_{2,2} + u_{3,1} = 3$</p><p>$u_{3,3} = u_{3,2} + u_{2,3} = 6$</p></blockquote><p>Cách triển khai này tương đồng với tam giác Pascal, nhưng thay vì là một tam giác, bảng của tôi lại định vị theo cột $m$ và dòng $n$</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif"></p><p>Tạm gọi ${k \choose r}$ với k là vị trí dòng (bắt đầu từ 0) và r là thứ tự từ trái sang phải (cũng bắt đầu tư 0), ta có công thức tổng quát như sau</p><blockquote><p>${k \choose r} = \frac{k!}{r! (k - r)!}$</p></blockquote><p>Công thức tìm giá trị này được chứng minh là bằng với C tổ hợp chập r của k phần tử (link chi tiết sẽ được cập nhật sau)</p><p>Vậy tôi biến đổi nó một chút. </p><p><img src="/images/pasted-4.png"></p><p><img src="/images/pasted-5.png"></p><p>Gạch đỏ là dòng $k$. Do $k, r$ bắt đầu = 0. $m, n$ bắt đầu = 1</p><blockquote><p>Xét $k = 2$ (gạch đỏ thứ 3), tồn tại 3 vị trí (m,n): $(1,3) (2,2) (3,1)$ lần lượt giá trị là $1, 2, 1$</p><p>Xét $k = 3$ (gạch đỏ thứ 4), tồn tại 4 vị trí (m,n): $(1,4) (2,3) (3,2) (4,1)$ lần lượt giá trị là $1, 3, 3, 1$. Thì $r$ vị trí tương ứng lần lượt là 0 - 1 - 2 - 3</p><p>=&gt; <strong>$k = (m - 1) + (n - 1) = m + n - 2$</strong>. Có thể hiểu $k$ là tổng phần tử toạ độ $m,n$ với giá trị lệch 2 (vì $m,n$ định nghĩa bắt đầu từ 1)</p><p>=&gt; $r = 1$ thì $(m,n) = (2,3)$, $r = 2$ thì $(m,n) = (3,2)$, $r = 3$ thì $(m,n) = (4,1)$ =&gt; <strong>$r = m - 1$</strong>. Có thể hiểu $r$ là hình chiếu lên toạ độ $m$ với giá trị lệch 1. Lấy $m$ cho dễ vì $r$ tăng thì $m$ tăng. Nếu muốn dùng $n$, thì cũng có thể $r = k - (n-1) = m + n - 2 - n + 1 = m - 1$ cuối cùng cũng triệt tiêu $n$ 👌</p></blockquote><p>Áp $k, r$ theo $m, n$ thì</p><blockquote><p>${k \choose r} = {m+n-2 \choose m-1} = \frac{(m+n-2)!}{(m-1)! (m+n-2- (m-1))!} = \frac{(m+n-2)!}{(m-1)!(n-1)!}$</p></blockquote><p>Như vậy, tổng kết CTTQ mà chúng ta sẽ có là</p><blockquote><p>$u_{m,n} = \frac{(m+n-2)!}{(m-1)!(n-1)!}$</p></blockquote><p>Công việc cuối cùng là chứng minh công thức dưới đây để tiện dùng hơn thông qua vài phép biến đổi (tôi sẽ không chứng minh chi tiết trong bài viết)</p><blockquote><p>$S_{m,n} = u_{m,n+1} = \frac{(m+n-1)!}{(m-1)!n!}$</p></blockquote><h1 id="Loi-ket"><a href="#Loi-ket" class="headerlink" title="Lời kết"></a>Lời kết</h1><p>Thông qua bài viết này, tôi hy vọng bạn đọc có thể tiếp tục mở ra nhiều hướng tiếp cận hay hơn, đồng thời nếu có sai sót, vui lòng liên hệ tôi để điều chỉnh kịp thời, tránh truyền tải sai.</p>]]></content>
      
      
      <categories>
          
          <category> Mathematic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> Dice </tag>
            
            <tag> Probability </tag>
            
            <tag> Python </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Văn hoá hỏi đáp trên StackOverflow</title>
      <link href="2021/04/01/Sinh-hoat-tren-StackOverflow-hieu-qua/"/>
      <url>2021/04/01/Sinh-hoat-tren-StackOverflow-hieu-qua/</url>
      
        <content type="html"><![CDATA[<p>StackOverFlow (SO) trong bài viết đề cập đến là một cộng đồng của các developer tại stackoverflow.com, mặc dù còn khá non trẻ khi ra đời vào khoảng 2008 nếu so sánh với các cộng đồng lớn mạnh khác, nhưng nó lại mang đến hiệu quả rất lớn cho hệ thống tri thức của dev, không khác gì wikipedia hay google.</p><p>Trước khi SO phổ biến, tôi thường hay đi qua codeproject, msdn, nhưng để lại ký ức trong đầu chả có gì ngoài đặt câu hỏi và giải thích rườm rà, code block thì í ẹ. Cộng đồng SO, dần dần tự cấu thành các quy chuẩn chung trong việc hỏi-đáp, không những giúp giải quyết code lẹ hơn, mà còn giúp cải thiện mindset cách người đặt câu hỏi và người trả lời. Đặt một câu hỏi gọn, lẹ, đơn giản, nghĩa là đã giải quyết được 50% vấn đề rồi.<br><img src="/images/right-question.png"></p><p>Mục tiêu của SO, chính là xây dựng một thư viện tri thức đồ sộ, mà nơi đó các developer có thể tìm được câu trả lời tiết kiệm thời gian nhất có thể. Do đó, đừng nên hiểu sai rằng SO là dịch vụ hỏi đáp, bởi SO chưa thu phí người dùng bao giờ. Nhiều developer còn ví von rằng, thà Google bị sập, còn hơn là StackOverflow bị sập.</p><h1 id="Nguoi-hoi-nen-tranh-nhung-gi"><a href="#Nguoi-hoi-nen-tranh-nhung-gi" class="headerlink" title="Người hỏi nên tránh những gì?"></a>Người hỏi nên tránh những gì?</h1><p>Có một sự thật hiển nhiên rằng nếu bạn không hiểu vấn đề của bạn, thì không ai sẽ chịu hiểu vấn đề của bạn cả. Một câu hỏi cộc lốc, trống không, không đầu không đuôi thì cũng sẽ không nhận được quan tâm, tất nhiên càng không nhận được câu trả lời thoả đáng. Tôi gần đây để ý thấy có nhiều cộng đồng Việt dành riêng cho dev cũng xuất hiện nhiều, nhưng tôi cũng thấy câu chuyện y như SO, khi mà các newbie chưa có <code>điểm tín dụng (reputation)</code>, thường không biết cách đặt câu hỏi, luôn bắt đầu bằng những câu ít tinh thần xây dựng</p><ul><li>Anh ơi, cứu em</li><li>Giúp này với</li><li>Nó đang bị gì vậy?</li><li>Giải bài tập với -&gt; Trang hỏi đáp chứ đâu phải dịch vụ giải bài tập đâu :(</li><li>Mình muốn làm này và này thì phải sao ạ -&gt; Thiếu sự đầu tư vào search google và phạm vi quá rộng để trở thành một câu hỏi tập trung</li></ul><p>Sau đó sẽ đi kèm với:</p><ul><li>Chụp màn hình đầy code -&gt; Bạn bắt người trả lời phải căng con mắt ra xem project của bạn </li><li>Chụp màn hình chứa lỗi -&gt; Có lỗi xảy ra thì ngoại trừ trường hợp cần trực quan, còn lại chỉ cần message là đủ, dòng message chỉ nơi xảy ra lỗi nó rất đáng giá.</li><li>Chụp màn hình bằng điện thoại -&gt; Bạn huỷ diệt sự kiên nhẫn của người trả lời</li><li>Post wall of code -&gt; Bạn bắt người trả lời phải đi vào chùm logic ngớ ngẩn của bạn, tất nhiên họ không buồn tìm hiểu. Ít nhất phải có sự tối giản hoá code (minimal and reproducible example) để người trả lời có thể reproduce lại nhanh nhất có thể</li><li>Hỏi nhiều câu hỏi cùng một lúc</li><li>Hỏi lan man, không tập trung câu hỏi</li><li>Hỏi dịch vụ này dịch vụ kia tốt không -&gt; Điều này sẽ tạo cơ hội cho seeder vào feed</li></ul><p>Tôi thấy cộng đồng VN tương đối dễ tính với những trường hợp như vậy, vì đa số toàn fresher, không chịu khó đọc tiếng anh, không rõ keyword hoặc thuật ngữ nào đó. Trên SO, nếu họ <em>không thấy mọi sự nỗ lực giải quyết vấn đề</em> của bạn, chắc chắn bạn sẽ ăn downvote đến nỗi bị xoá đi :)</p><h1 id="Vai-tro-cua-nguoi-tra-loi"><a href="#Vai-tro-cua-nguoi-tra-loi" class="headerlink" title="Vai trò của người trả lời?"></a>Vai trò của người trả lời?</h1><p>Người trả lời, có thể xem như cứu tinh của vấn đề, thậm chí có thể lên ngôi đền huyền thoại chỉ vì một câu hỏi được trả lời từ thuở sơ khai của SO. Người trả lời không trả lời những câu vô nghĩa, hoặc chỉ mang tính <code>bình luận</code> và <code>không chắc chắn</code>:</p><ul><li>Bạn thử này xem được không</li><li>Bạn có biết suy nghĩ của bạn bla bla bla không</li><li>Đưa link, hoặc wall of code rồi chạy đi không một lời giải thích</li><li>Thay vì đưa ra giải pháp tối ưu, chí ít thì cũng thể đưa ra một giải pháp đi vòng (workaround), chứ không chọn giải pháp tiêu cực: VD <strong>Windows tôi bị lỗi driver, tôi hỏi driver phù hợp -&gt; Câu trả nhận được là tôi hãy Cài lại Windows đi !?</strong>. Đây là câu chuyện xảy ra trên vn-zoom hồi khoảng 2008 mà tôi tham gia, post nào cũng nhại lại câu này mãi, gây ức chế người hỏi lẫn người đọc khi đang search tìm.</li><li>Nếu quá lớn, hoặc quá chuyên sâu, bạn cũng có thể đưa ý tưởng, tuy nhiên không nên lạm dụng vì sẽ rất dễ bị confuse giữa bình luận và trả lời, tuỳ tính chất, nhưng cộng đồng SO sẽ không quá khắt khe, miễn nó có lập luận hợp lý.</li></ul><h1 id="Hoi-dap-van-hoa-chuyen-nghiep"><a href="#Hoi-dap-van-hoa-chuyen-nghiep" class="headerlink" title="Hỏi đáp văn hoá, chuyên nghiệp"></a>Hỏi đáp văn hoá, chuyên nghiệp</h1><p>Trên SO, có một thứ khá thú vị, đó là nếu bạn đạt được điểm tín dụng cao, bạn sẽ unlock được các quyền hạn đặc biệt</p><p><img src="/images/privileges.png"></p><p>Bạn sẽ có nhiều quyền unlock như upvote, comment, edit bài viết, review bài vote của newbie để đánh giá có phù hợp hay không. Điểm tín dụng cao không phải chỉ ở người trả lời mà còn ở người hỏi, cách nỗ lực giải quyết vấn đề, các câu hỏi hay.</p><p>Tựu trung lại, cộng đồng SO sẽ thích template như sau:</p><blockquote><p>Chào mọi người,..<br>Mình đang bị vấn đề này…<br>Mình cố gắng như này, nhưng chỉ ra cái nọ<br>Mình nghi vấn này…, mình cũng có thí nghiệm thêm vài case khác để củng cố giả thuyết<br>Thêm hình/video nếu có (Không phải hình crash, vì message đã có đủ thông tin hình crash, chỉ cần hình mô tả trực quan về UI)<br>Code đã được minimal và reproducible<br>Môi trường đi kèm (.NET Core 3.0, Windows 10 Build xxxx,…)<br>Cám ơn<br>Gắn tag phù hợp (vd C#, Python, Azure Function, SQL,…)</p></blockquote><p>Ở đây ắt sẽ có câu hỏi đặt ra là nếu đã có minimal example rồi thì cần gì phải hỏi? Thực tế, việc bạn minize program rồi thì sẽ có hơn 70% khả năng bạn đã tự giải đáp vấn đề, do đó, không còn cách nào khác bạn phải tự trang bị kỹ năng debug, kỹ năng lập luận, suy luận và đặt nghi vấn, thậm chí là tạo một project khác để test nó luôn<br>nếu muốn tăng kiến thức.</p><p>Nếu bạn biết đặt câu hỏi đúng, sẽ có khả năng lớn chính developer của project đó đứng ra giải quyết giúp bạn, tôi có 2 lần may mắn được một bác senior Google Map và một bác Microsoft Azure Function giúp giải quyết luôn vấn đề. Quá tuyệt vời luôn :)</p>]]></content>
      
      
      <categories>
          
          <category> Softskill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StackOverflow </tag>
            
            <tag> Softskill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Con đường đến với lập trình</title>
      <link href="2021/03/28/Bai-viet-dau-tien/"/>
      <url>2021/03/28/Bai-viet-dau-tien/</url>
      
        <content type="html"><![CDATA[<p>Tôi tiếp xúc chiếc máy tính đầu tiên lúc Windows 98 còn thông dụng, tuy nhiên nó quá đắt đỏ và hầu như tôi chỉ chơi game đơn giản, lớn hơn một chút thì tôi cũng biết la cà quán net để nhìn người ta chơi. Mãi đến khi tôi lớp 4, cả nhà đã cố gắng mua về 1 chiếc PC, mà theo tôi nhớ tổng giá trị khoảng 14 triệu, bằng với chiếc Alpha Wave mà ba tôi mới mua.</p><p>Tất nhiên tôi cũng đã vọc phá đến hư windows, ông chú - bạn của ba tôi hay qua sửa máy tính thường xuyên. Một lần vì đợi lâu quá, tôi cũng ráng làm liều, reset BIOS, rồi boot cài windows theo hướng dẫn ở vn-zoom, không giống như bây giờ, hầu như driver phải tận dụng từ đĩa cài, chứ rất ít có trên mạng, phải cố gắng nhiều lần mới qua được ải.</p><p>Năm lớp 8, tôi được lựa chọn vào đội tuyển Tin, được khoảng 2 tháng (cũng do còn ham chơi) cộng với yếu tố Pascal nó lại không khiến tôi hứng thú so với ngôn ngữ thịnh hành lúc bấy giờ là PHP. Suy tính kỹ, tôi quyết định nghỉ ngang, đi đăng ký lớp học PHP &amp; MySQL của một trung tâm tương đối lớn của HCM lúc bấy giờ là Việt Chuyên. Học xong thì cũng biết được cách làm web cơ bản, tôi lại tiếp tục đi trải nghiệm tiếp ở UI/UX, tôi thậm chí còn đi thử Photoshop, Firework, làm clip aegisub, Proshow Producer,… xong được một vài project thì tôi cũng bỏ, vì thấy không phải quá đam mê.</p><h1 id="Nhan-thuc-moi"><a href="#Nhan-thuc-moi" class="headerlink" title="Nhận thức mới"></a>Nhận thức mới</h1><p>Lên lớp 11, tôi vớ được cuốn giáo trình tự học Android ở Thư viện Tổng hợp TPHCM, thế là tôi bắt đầu tự học Java, rồi cũng thử đi thi Tin học trẻ và được giải 3, lãnh 2 củ tiền mặt, tiếp tục lên quốc gia thì tạch :(. Tôi cứ tưởng tôi sẽ theo luôn Android, nhưng tôi lại rơi vào chán nản vì giải quyết UI/UX của Android cũng chẳng khác gì với Web là bao, trong khi giải quyết phần logic nhiều hơn lại khiến tôi có thể suy nghĩ về nó cả ngày. </p><p>Nó cũng giống như tôi đi giải Toán vậy, lớp 12 do trường tôi không có phong trào Tin học, nên tôi chọn đội tuyển Toán, hầu như giải toán cả ngày, thầy cô dạy toán cấp 3 của tôi đã truyền cảm hứng Toán học vào trong tôi. Dù là rất cố gắng, nhưng sự đầu tư và điểm rơi phong độ không đúng, tôi không được giải HSG Toán 12 gì cả :(, bẵng đi đến năm 3 Đại học, tôi mới có giải Olympic Sinh Viên môn Giải tích để lận lưng, chụp báo lại thầy cấp 3 ngay và luôn.</p><p>Sau khi đi thi Toán ở Quảng Bình về và tham vấn từ nhiều senior, tôi quyết định rẽ luôn ngành Data, nơi mà tôi có thể kết hợp áp dụng phần logic, toán học với Software Engineering mà tôi mong muốn. Tôi có thể không cần chạy theo công nghệ như Angular, Android Kotlin, nhưng tôi luôn sẵn sàng có thể áp dụng tất cả những kỹ thuật mới, hoặc academic bất kỳ để phục vụ business. Ở thời điểm hiện tại, tôi vẫn còn đang theo và chưa hề có ý định từ bỏ (kiếm cơm mà :( ), dù rất là cực vì có mặt hầu hết ở mọi điểm nóng của hệ thống, nhưng bù lại tôi cũng học được rất nhiều, có được cái nhìn tổng quan, cách optimize hệ thống bằng cách lượm lặt những kiến thức đã cày ở Toán-Tin.</p><h1 id="Nhin-lai"><a href="#Nhin-lai" class="headerlink" title="Nhìn lại"></a>Nhìn lại</h1><p>Nhìn lại, con đường tôi đã đi nó đụng vô số thứ, dù chỉ loanh quanh ở IT, nhưng lại khiến tôi mất thời gian quá nhiều về cách định hướng. Tôi từng nghe nhiều thầy cô giảng viên Đại học từng chia sẻ, khi con cái mình có được một kiến thức và tầm nhìn tốt, bạn sẽ được định hướng rõ ràng từ trong trứng nước, dù vẫn cho thử nghiệm để biết concept, nhưng sau đó rút ngay trong một thời gian hạn định để tập trung cho con đường chuyên nghiệp. Nghe thoáng qua thì như máy móc, nhưng thực tế sẽ cho thấy, bạn đã hơn vạch xuất phát nhiều đến mức nào.</p><p>Quả thật, trong các kinh thánh, hay câu chuyện triết học tôi có đọc qua đều có đề cao người dẫn dắt, dẫn lối cho mình. Dù lối đi ngay dưới chân mình, nhưng tầm nhìn của lối đi không phải mình luôn mường tượng được :)</p>]]></content>
      
      
      <categories>
          
          <category> Personal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> about </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
